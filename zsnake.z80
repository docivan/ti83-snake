.NOLIST
#define equ .equ
#define EQU .equ
#define end .end
#include "ti83asm.inc"
#include "tokens.inc"

; #######################################################################################
; CONSTANTS
; #######################################################################################

WAITKEY .equ     4CFEh  ; Wait for a key and read
BUFCLR	.equ	 515Bh	; Clear the graph backup
BUFCOPY .equ	 5164h	; Copy the graph backup to the screen
RINDOFF .equ	 4795h	; Turn off runindicator
PRINTHL .equ	 4709h	; Print HL in dec. on the screen
OP2TOP1 .equ	 41C2h	; Move OP2 to OP1
CONVOP1 .equ	 4EFCh	; Convert fp value in OP1 to a 2 byte hex
READKEY .equ	 4A18h	; Read key and place it in OP2 as a fp value
GOHOME	.equ	 47A1h	; Go to home screen (finish gfx program)
CLRTSHD .equ	 4765h	; Clear text shadow
HOMEUP	.equ	 4775h	; Place cursor at home
STRING	.equ	 470Dh	; Print 0 terminated string to screen (hl->string)

_vram	.equ	8E29h ; video mem

; #######################################################################################
; USER DEFINED CONSTANTS
; #######################################################################################

snake_len_max	.equ	64
apple_cnt		.equ	10
scr_w 			.equ	96
scr_h				.equ	64
scr_w_b			.equ	scr_w/8

DIR_N				.equ	0
DIR_E				.equ	1
DIR_S				.equ	2
DIR_W				.equ	3

key_UP			.equ	4
key_DOWN			.equ	1
key_LEFT			.equ	2
key_RIGHT		.equ	3

; #######################################################################################
; PROGRAM ENTRY POINT
; #######################################################################################

.LIST
.org 9327h

	; prep environment
	call RINDOFF         ; Turn off runindicator
	call menu
	ret

; #######################################################################################
; MENU
; #######################################################################################

menu:
	; TODO
	call BUFCLR          ; Clear the graphbuf
	call BUFCOPY         ; Copy the graphbuf to the LCD
	
	call start_game
	ret

; #######################################################################################
; START GAME
; #######################################################################################

start_game:
	call draw_map
	
	;generate apples
	ld a,apple_cnt
apple_loop:
	push af
	call gen_apple
	pop af
	dec a
	jp nz, apple_loop
	
	call BUFCOPY
	call game_loop
	ret

; #######################################################################################
; GAME LOOP
; #######################################################################################

cur_map:		.dw	0
dir:			.db	DIR_E
snake_len:	.db	3
stop_game:	.db	0
speed:		.dw	3000
game_loop:
	; below is the main vgame loop
	
	;move + draw
	call move_snake
	call draw_snake
	call draw_apples
	call BUFCOPY	;blit
	
	; handle collisions
	call check_collision
	
	ld a,(stop_game) ; check if we finished
	cp 1
	ret z
	; TODO use the snake segments for an explosion!
	
	;idle while getting input
	ld hl,(speed)		; otherwise sleep for 30ms and loop
gl_idle:
	push hl
	call handle_input
	pop hl
	dec hl
	ld a,h
	or l
	jp nz, gl_idle
	
	jp game_loop
	ret

draw_apples:
	;TODO
	ret

gen_apple:
	;TODO
	ret

; #######################################################################################
; HANDLE INPUT
; #######################################################################################

handle_input
	call _GetK
	
	cp key_UP
	jp z,kp_UP
	cp key_DOWN
	jp z,kp_DOWN
	cp key_LEFT
	jp z,kp_LEFT
	cp key_RIGHT
	jp z,kp_RIGHT
	ret

kp_UP:
	ld a, DIR_N
	ld (dir), a
	ret
kp_DOWN:
	ld a, DIR_S
	ld (dir), a
	ret
kp_LEFT:
	ld a, DIR_W
	ld (dir), a
	ret
kp_RIGHT:
	ld a, DIR_E
	ld (dir), a
	ret

check_collision:
	; TODO
		;TODO
	;check eating apple
	;gen apples
	ret

; #######################################################################################
; MOVE SNAKE
; #######################################################################################

move_snake:
	call clear_tail
	call move_body
	call move_head
	

clear_tail:
	;find tail
	ld hl,snake
	ld de,(snake_len)
	dec de
	
	add hl,de
	add hl,de
	
	ld a,(hl)
	inc hl
	ld b,(hl)
	
	call clr_pxl
	ret

move_body:
	ld hl,snake
	ld de,(snake_len)
	dec de
	
	add hl,de
	add hl,de
	inc hl
	
	; now copy
	ld d,h
	ld e,l	; now both pointing at y-coor of the last elem
	
	dec de
	dec de	; de is now 1 segm ahead
	
	ld a,(snake_len)
	dec a
	add a,a
	ld b,a

ms_cpy_loop:
	ld a,(de)
	ld (hl),a
	dec hl
	dec de
	dec b
	jp nz,ms_cpy_loop
	
	ret
	
	; 00 00 00
	
	; move in current dir
move_head:
	ld a,(dir)
	cp DIR_N
	jp z,mv_north
	cp DIR_S
	jp z,mv_south
	cp DIR_W
	jp z,mv_west
	cp DIR_E
	jp z,mv_east
	
mv_south:
	ld hl,snake
	inc hl
	ld a,(hl)
	inc a
	cp scr_h
	jp c, noob_south
	ld a,0
noob_south:  			; not out of bounds
	ld (hl),a
	ret
	
mv_north:
	ld hl,snake
	inc hl
	ld a,(hl)
	dec a
	jp p, noob_north	;>=0
	ld a,scr_h-1
noob_north:  			; not out of bounds
	ld (hl),a
	ret
	
mv_west:
	ld hl,snake
	ld a,(hl)
	dec a
	jp p, noob_west ; >=0
	ld a,scr_w-1
noob_west:  			; not out of bounds
	ld (hl),a
	ret

mv_east:
	ld hl,snake
	ld a,(hl)
	inc a
	cp scr_w
	jp c, noob_east
	ld a,0
noob_east:  			; not out of bounds
	ld (hl),a
	ret


; #######################################################################################
; delay: idle for a given number of cycles (given by de) in multiplicants of 0xffff
;
; input: delay de * 0xffff
; returns nothing
; #######################################################################################

;6 MHz, ie 6 000 000 / s
; 1ms = 1000 / s
; thus need to perform 6000 cycles for 1 ms

delay:
	ld hl,249				; 24*249 = 5976 cycles + 29 for the outer = 6005c
	
delay_loop:
	dec hl					; 6 cycles
	ld a,h					; 4 cycles	; cp low byte
	or l						; 4 cycles	; cmp with hi byte - if both not 0 - continue inner loop
	jp nz, delay_loop		; 10 cycles
	
	dec de					;6c
	ld a,d					;4c
	or e						;4c
	ret z						;5c
	jp delay					;10c

; thus 24c per inner loop + 29c for outer

; #######################################################################################
; draw_snake: draw snake
;
; no inputs
; returns nothing
; #######################################################################################

draw_snake:
	ld hl, snake
	ld de, (snake_len)
	
ds_loop:
	ld a,(hl)
	inc hl
	ld b,(hl)
	inc hl
	
	push hl
	push de
	call put_pxl
	pop de
	pop hl
	
	dec e
	jp nz, ds_loop
	
	ret

; #######################################################################################
; draw_map: draw initial map
;
; no inputs
; returns nothing
; #######################################################################################

dmloopvar: .db 48
dmbytecnt: .db	3
draw_map:
	ld hl,_vram-1
	ld de,lvl1_map
	ld b,00000001b
	rr b ;carry primed with 1

dmloop:
	rr b				;shift to next bit in map mask byte
	jp z,dmnxtbyte	;if it is zero, load next byte from map
	
	inc hl 			;switch to next byte in _vram for every two bits in map
	ld a,(de)		;get current map byte
	and b				;and mask
	jp z,dmbit2		;if empty - go to next bit
	ld c,11110000b
	call draw_tile
dmbit2:
	rr b				;shift to next bit in map mask byte
	ld a,(de)		;get current map byte
	and b				;and mask
	jp z,dmloop		;if there is nothing to draw, continue with next 2 bits
	ld c,00001111b
	call draw_tile
	ld a,(hl)		;load vram byte
	or c				;apply it on top of already drawn mem
	ld (hl),a		;cp to vram
	jp dmloop
dmnxtbyte:
	inc de			;load next map byte
	
	ld a,(dmloopvar)
	dec a
	ret z
	ld (dmloopvar),a
	
	ld a,(dmbytecnt)
	dec a
	ld (dmbytecnt),a
	jp nz,dmloop
	
	ld a,3
	ld (dmbytecnt),a
	
	push af
	push de
	ld de,36
	add hl,de
	pop de
	pop af
	
	jp dmloop		;continue

draw_tile
	push bc
	push de
	push hl
	
	ld b,4
	ld de,12

dt_loop:
	ld a,(hl)
	or c
	ld (hl),a
	
	add hl,de
	dec b
	jp nz, dt_loop
	
	pop hl
	pop de
	pop bc
	ret

; #######################################################################################
; gen_rnd_xy: generate random coords (a,) within screen limits
;
; no inputs
; returns nothing
; #######################################################################################
gen_rnd_xy:
	; gen y
	ld a,scr_h-1
	call gen_rnd
	ld b,a
	; gen x
	push bc
	ld a,scr_w-1
	call gen_rnd
	pop bc
	; done
	ret

; #######################################################################################
; TESTING FUNCS
; #######################################################################################

test_pxl:
	ld hl,_vram
	ld c,12
	ld b,0
	add hl,bc
	ld (hl), 10101010b
	;call BUFCOPY
	
	ld de,12*20
	ld c,0
	;call put_pxl
	
	ld de,12*20
	ld c,2
	;call put_pxl
	
	ld de,12*20
	ld c,4
	;call put_pxl
	
	ld de,12*20
	ld c,6
	;call put_pxl
	
	ld a,47
	ld b,31
	call put_pxl
	
	ld a,0
	ld b,1
	call clr_pxl
	
	ld a,2
	ld b,1
	call clr_pxl
	
	call BUFCOPY
	ret

test_mul:
; mul a*b = hl
; kills de, hl, ab
; result in hl
	ld a,12
	ld b,4
	call mul
	call _dispHL
	
	ld a,4
	ld b,12
	call mul
	call _dispHL
	
	ld a,0
	ld b,12
	call mul
	call _dispHL
	
	ld a,12
	ld b,0
	call mul
	call _dispHL
	ret

test_div:
	ld d,255
	ld e,2
	call div
	ld h,0
	ld l,a
	push bc
	call _dispHL
	pop bc
	ld h,0
	ld l,b
	call _dispHL
	
	ld d,15
	ld e,0
	call div
	ld h,0
	ld l,a
	push bc
	call _dispHL
	pop bc
	ld h,0
	ld l,b
	call _dispHL
	ret

test_div_unsafe:
	ld a,15
	ld b,5
	call div_unsafe
	ld h,0
	ld l,d
	push de
	call _dispHL
	pop de
	ld h,0
	ld l,e
	call _dispHL
	
	ld a,15
	ld b,6
	call div_unsafe
	ld h,0
	ld l,d
	push de
	call _dispHL
	pop de
	ld h,0
	ld l,e
	call _dispHL
	
	; floating division
	ld a,5
	ld b,15
	call div_unsafe
	ld h,0
	ld l,d
	push de
	call _dispHL
	pop de
	ld h,0
	ld l,e
	call _dispHL
	ret

; #######################################################################################
; PIXEL MANIPULATION
; #######################################################################################

; #######################################################################################
; put_pxl: put pixel at (a,b)
;
; kills bascially everything
; returns nothing
; #######################################################################################

put_pxl:
	call get_vram_addr
	
	ld hl, bitmasks
	ld b,0
	add hl,bc
	ld c,(hl) ; bitmask is now stored in c
	
	ld hl, _vram
	add hl,de
	ld a,(hl)
	or c			; XOR
	
	ld (hl),a 	; put back the byte
	ret

; #######################################################################################
; clr_pxl: clear pixel at (a,b)
;
; kills bascially everything
; returns nothing
; #######################################################################################

clr_pxl:
	;the same as put_pxl, but with an extra NOT (cpl) and AND
	call get_vram_addr
	
	ld hl, bitmasks
	ld b,0
	add hl,bc
	ld c,(hl) ; bitmask is now stored in c
	ld a,c
	cpl			;NOT
	ld c,a
	
	ld hl, _vram
	add hl,de
	ld a,(hl)
	and c			; AND
	
	ld (hl),a 	; put back the byte
	ret

; get pixel val from (a,b)
; returns nothing

get_pxl:
	; TODO
	ret

; #######################################################################################
; get_vram_addr: convert coords (a,b) to array idx (de) and which bit to flip (c)
;
; kills bascially everything
; returns de, c
; #######################################################################################

get_vram_addr:	
	; idx = y*scr_w_ch + (int)(x/8)
	; bit = rest after div
	
	ld d,a
	ld e,8
	push de
	
	; y*scr_w_b
	ld a,b
	ld b,scr_w_b
	call mul 		;result in hl
	
	pop de	; get ready for division
	push hl 	; push result on the stack
	call div	; now a = result, b = rest
	
	ld d,0
	ld e,a
	
	pop hl
	add hl,de
	
	; return values
	ld d,h
	ld e,l
	
	ld c,b
	
	ret


; #######################################################################################
; div: perform multiplication of two 8 byte integers hl = a*b
;
; kills de, hl, ab
; returns hl
; #######################################################################################

mul:
	ld hl,0
	ld d,0
	
	; is a == 0?
	cp d
	jp z, mul_zero
	
	; speed up by forking according to a>b?
	cp b
	jp c,mul_b_lt_a
	
	;a>b
	ld e,a
	jp mul_loop
    
	;b>a
mul_b_lt_a:
	ld e,b
	ld b,a

mul_loop:
	add hl,de
	dec b
	jp pe, mul_zero ; b == -1, ie was == 0
	jp nz, mul_loop
	
	ret
	
mul_zero: ; multipleier is zero
	ld hl,0
	ret
    

; #######################################################################################
; div_unsafe: perform 8 byte integer division d = a/b, e = rest
; NB! div/0 will hang the machine!
;
; kills <none>
; returns de
; #######################################################################################
div_unsafe:
	ld d,0
	
div_unsafe_loop:
	inc d
	sub b
	jp nc, div_unsafe_loop
	
	dec d
	add a,b
	ld e,a 
	ret


; #######################################################################################
; div: perform 8 byte integer division a = d/e, b = rest
;
; kills <none>
; returns ab
; #######################################################################################

div:
	; avoid div/0
	ld a,0
	cp e
	jp nz, div_non_zero
	ld b,0
	ret

div_non_zero:
	ld a,d
	ld d,0
div_loop:
	inc d
	sub e
	jp nc, div_loop
	
	dec d		; wind back div counter with 1
	add a,e	; add divident to get rest
	
	; store in de
	ld b,a
	ld a,d
	ret


; #######################################################################################
; gen_rnd: generate a random number from 0 up to and including max
;
; reg a = max value <256
; kills e
; returns a
; #######################################################################################
gen_rnd:
	ld e,a
	push de			; save parsed params
	call _RANDOM	; call internal routine
   ld a,(OP1+6)	; get the random nr stored in (OP1 + 6)
   pop de 			; get parsed params back
gen_rnd_loop:
	sub e				; a-e
	jp nc,gen_rnd_loop ; if result < 0, continue
	
	add a,e			; add max_val to result to make it positive
	ld e,a			; store it in a
	
	; this is to make this function inclusive of max_val
	ld a,r			; get mem refresh register
	and 00000010b	; mask bit 6 only (the last bit (7) is not altered by mem refresh)
	jp z,gen_rnd_finished
	
	inc e				; if the bit is 1, increase value
	
gen_rnd_finished:
	ld a,e			; store return value in a
	ret

; #######################################################################################
; sprites and other mem defines

; LUTS

bitmasks:
	.db 10000000b ;0
	.db 01000000b ;1
	.db 00100000b ;2
	.db 00010000b ;3
	.db 00001000b ;4
	.db 00000100b ;5
	.db 00000010b ;6
	.db 00000001b ;7

; assets

lvl1_map: ;3x16 bytes
	.db 11000000b, 00000000b, 00000011b
	.db 10000000b, 00000000b, 00000001b
	.db 00000000b, 00111100b, 00000000b
	.db 00000000b, 00000000b, 00000000b
	.db 00000000b, 00000000b, 00000000b
	.db 00000000b, 00000000b, 00000000b
	.db 00000000b, 00000000b, 00000000b
	.db 00000000b, 00000000b, 00000000b
	.db 00000000b, 00000000b, 00000000b
	.db 00000000b, 00000000b, 00000000b
	.db 00000000b, 00000000b, 00000000b
	.db 00000000b, 00000000b, 00000000b
	.db 00000000b, 00000000b, 00000000b
	.db 00000000b, 00111100b, 00000000b
	.db 10000000b, 00000000b, 00000001b
	.db 11000000b, 00000000b, 00000011b

snake:
	.db  48, 31,  47, 31,  46, 31, 255,255, 255,255, 255,255, 255,255, 255,255,
	.db 255,255, 255,255, 255,255, 255,255, 255,255, 255,255, 255,255, 255,255,
	.db 255,255, 255,255, 255,255, 255,255, 255,255, 255,255, 255,255, 255,255,
	.db 255,255, 255,255, 255,255, 255,255, 255,255, 255,255, 255,255, 255,255,
	.db 255,255, 255,255, 255,255, 255,255, 255,255, 255,255, 255,255, 255,255,
	.db 255,255, 255,255, 255,255, 255,255, 255,255, 255,255, 255,255, 255,255,
	.db 255,255, 255,255, 255,255, 255,255, 255,255, 255,255, 255,255, 255,255,
	.db 255,255, 255,255, 255,255, 255,255, 255,255, 255,255, 255,255, 255,255

apples:
	.db 255,255, 255,255, 255,255, 255,255, 255,255, 255,255, 255,255, 255,255, 255,255

.end
