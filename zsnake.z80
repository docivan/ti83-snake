.NOLIST
#define equ .equ
#define EQU .equ
#define end .end
#include "ti83asm.inc"
#include "tokens.inc"

; #######################################################################################
; CONSTANTS
; #######################################################################################

WAITKEY .equ     4CFEh  ; Wait for a key and read
BUFCLR	.equ	 515Bh	; Clear the graph backup
BUFCOPY .equ	 5164h	; Copy the graph backup to the screen
RINDOFF .equ	 4795h	; Turn off runindicator
PRINTHL .equ	 4709h	; Print HL in dec. on the screen
OP2TOP1 .equ	 41C2h	; Move OP2 to OP1
CONVOP1 .equ	 4EFCh	; Convert fp value in OP1 to a 2 byte hex
READKEY .equ	 4A18h	; Read key and place it in OP2 as a fp value
GOHOME	.equ	 47A1h	; Go to home screen (finish gfx program)
CLRTSHD .equ	 4765h	; Clear text shadow
HOMEUP	.equ	 4775h	; Place cursor at home
STRING	.equ	 470Dh	; Print 0 terminated string to screen (hl->string)

_vram	.equ	8E29h ; video mem

; #######################################################################################
; USER DEFINED CONSTANTS
; #######################################################################################

snake_len_max	.equ	64
scr_w 			.equ	96
scr_h				.equ	64
scr_w_b			.equ	scr_w/8

DIR_N				.equ	0
DIR_E				.equ	1
DIR_S				.equ	2
DIR_W				.equ	3

; #######################################################################################
; PROGRAM ENTRY POINT
; #######################################################################################

.LIST
.org 9327h

	; prep environment
	call    RINDOFF         ; Turn off runindicator
	call    BUFCLR          ; Clear the graphbuf
	call    BUFCOPY         ; Copy the graphbuf to the LCD
	
	call init_snake
	
main_loop:
	;call menu
	
	call init_snake
	call draw_map
	call BUFCOPY
	
	; below is the main vgame loop
	call draw_snake
	
	call move_snake
	call handle_input
	
	ret

dmloopvar: .db 48
draw_map:
	ld hl,_vram-1
	ld de,lvl1_map
	ld b,00000001b
	rr b ;carry primed with 1
	;ret


dmloop:
	rr b				;shift to next bit in map mask byte
	jp z,dmnxtbyte	;if it is zero, load next byte from map
	
	inc hl 			;switch to next byte in _vram for every two bits in map
	ld a,(de)		;get current map byte
	and b				;and mask
	jp z,dmbit2		;if empty - go to next bit
	ld (hl),11110000b	;draw
dmbit2:
	rr b				;shift to next bit in map mask byte
	ld a,(de)		;get current map byte
	and b				;and mask
	jp z,dmloop		;if there is nothing to draw, continue with next 2 bits
	ld c,00001111b	;otherwise load what to draw
	ld a,(hl)		;load vram byte
	or c				;apply it on top of already drawn mem
	ld (hl),a		;cp to vram
	jp dmloop
dmnxtbyte:
	inc de			;load next map byte
	ld a,(dmloopvar)
	dec a
	ret z
	ld (dmloopvar),a
	jp dmloop		;continue

handle_input
	; TODO
	ret

move_snake:
	;TODO
	ret

draw_snake:
	;TODO
	ld hl, snake_head
	
	ret

init_snake:
	ld hl, snake_head
	
	ld (hl),48	 ;x
	inc hl
	ld (hl),31 ;y
	inc hl
	
	ld (hl),47	 ;x
	inc hl
	ld (hl),31 ;y
	inc hl
	
	ld (hl),46	 ;x
	inc hl
	ld (hl),31 ;y
	inc hl
	
	ret

;puts in coords in (a,b)
gen_rnd_xy:
	; gen y
	ld a,scr_h-1
	call gen_rnd
	ld b,a
	; gen x
	push bc
	ld a,scr_w-1
	call gen_rnd
	pop bc
	; done
	ret
	

cur_map:	.dw	0

pos_x:	.db	0
pos_y:	.db	0
dir:		.db 	0

; #######################################################################################
; TESTING FUNCS
; #######################################################################################

test_pxl:
	ld hl,_vram
	ld c,12
	ld b,0
	add hl,bc
	ld (hl), 10101010b
	;call BUFCOPY
	
	ld de,12*20
	ld c,0
	;call put_pxl
	
	ld de,12*20
	ld c,2
	;call put_pxl
	
	ld de,12*20
	ld c,4
	;call put_pxl
	
	ld de,12*20
	ld c,6
	;call put_pxl
	
	ld a,47
	ld b,31
	call put_pxl
	
	ld a,0
	ld b,1
	call clr_pxl
	
	ld a,2
	ld b,1
	call clr_pxl
	
	call BUFCOPY
	ret

test_mul:
; mul a*b = hl
; kills de, hl, ab
; result in hl
	ld a,12
	ld b,4
	call mul
	call _dispHL
	
	ld a,4
	ld b,12
	call mul
	call _dispHL
	
	ld a,0
	ld b,12
	call mul
	call _dispHL
	
	ld a,12
	ld b,0
	call mul
	call _dispHL
	ret

test_div:
	ld d,255
	ld e,2
	call div
	ld h,0
	ld l,a
	push bc
	call _dispHL
	pop bc
	ld h,0
	ld l,b
	call _dispHL
	
	ld d,15
	ld e,0
	call div
	ld h,0
	ld l,a
	push bc
	call _dispHL
	pop bc
	ld h,0
	ld l,b
	call _dispHL
	ret

test_div_unsafe:
	ld a,15
	ld b,5
	call div_unsafe
	ld h,0
	ld l,d
	push de
	call _dispHL
	pop de
	ld h,0
	ld l,e
	call _dispHL
	
	ld a,15
	ld b,6
	call div_unsafe
	ld h,0
	ld l,d
	push de
	call _dispHL
	pop de
	ld h,0
	ld l,e
	call _dispHL
	
	; floating division
	ld a,5
	ld b,15
	call div_unsafe
	ld h,0
	ld l,d
	push de
	call _dispHL
	pop de
	ld h,0
	ld l,e
	call _dispHL
	ret

; #######################################################################################
; PIXEL MANIPULATION
; #######################################################################################

; #######################################################################################
; put_pxl: put pixel at (a,b)
;
; kills bascially everything
; returns nothing
; #######################################################################################

put_pxl:
	call get_vram_addr
	
	ld hl, bitmasks
	ld b,0
	add hl,bc
	ld c,(hl) ; bitmask is now stored in c
	
	ld hl, _vram
	add hl,de
	ld a,(hl)
	xor c			; XOR
	
	ld (hl),a 	; put back the byte
	ret

; #######################################################################################
; clr_pxl: clear pixel at (a,b)
;
; kills bascially everything
; returns nothing
; #######################################################################################

clr_pxl:
	;the same as put_pxl, but with an extra NOT (cpl) and AND
	call get_vram_addr
	
	ld hl, bitmasks
	ld b,0
	add hl,bc
	ld c,(hl) ; bitmask is now stored in c
	ld a,c
	cpl			;NOT
	ld c,a
	
	ld hl, _vram
	add hl,de
	ld a,(hl)
	and c			; AND
	
	ld (hl),a 	; put back the byte
	ret

; get pixel val from (a,b)
; returns nothing

get_pxl:
	; TODO
	ret

; #######################################################################################
; get_vram_addr: convert coords (a,b) to array idx (de) and which bit to flip (c)
;
; kills bascially everything
; returns de, c
; #######################################################################################

get_vram_addr:	
	; idx = y*scr_w_ch + (int)(x/8)
	; bit = rest after div
	
	ld d,a
	ld e,8
	push de
	
	; y*scr_w_b
	ld a,b
	ld b,scr_w_b
	call mul 		;result in hl
	
	pop de	; get ready for division
	push hl 	; push result on the stack
	call div	; now a = result, b = rest
	
	ld d,0
	ld e,a
	
	pop hl
	add hl,de
	
	; return values
	ld d,h
	ld e,l
	
	ld c,b
	
	ret


; #######################################################################################
; div: perform multiplication of two 8 byte integers hl = a*b
;
; kills de, hl, ab
; returns hl
; #######################################################################################

mul:
	ld hl,0
	ld d,0
	
	; is a == 0?
	cp d
	jp z, mul_zero
	
	; speed up by forking according to a>b?
	cp b
	jp c,mul_b_lt_a
	
	;a>b
	ld e,a
	jp mul_loop
    
	;b>a
mul_b_lt_a:
	ld e,b
	ld b,a

mul_loop:
	add hl,de
	dec b
	jp pe, mul_zero ; b == -1, ie was == 0
	jp nz, mul_loop
	
	ret
	
mul_zero: ; multipleier is zero
	ld hl,0
	ret
    

; #######################################################################################
; div_unsafe: perform 8 byte integer division d = a/b, e = rest
; NB! div/0 will hang the machine!
;
; kills <none>
; returns de
; #######################################################################################
div_unsafe:
	ld d,0
	
div_unsafe_loop:
	inc d
	sub b
	jp nc, div_unsafe_loop
	
	dec d
	add a,b
	ld e,a 
	ret


; #######################################################################################
; div: perform 8 byte integer division a = d/e, b = rest
;
; kills <none>
; returns ab
; #######################################################################################

div:
	; avoid div/0
	ld a,0
	cp e
	jp nz, div_non_zero
	ld b,0
	ret

div_non_zero:
	ld a,d
	ld d,0
div_loop:
	inc d
	sub e
	jp nc, div_loop
	
	dec d		; wind back div counter with 1
	add a,e	; add divident to get rest
	
	; store in de
	ld b,a
	ld a,d
	ret


; #######################################################################################
; gen_rnd: generate a random number from 0 up to and including max
;
; reg a = max value <256
; kills e
; returns a
; #######################################################################################
gen_rnd:
	ld e,a
	push de			; save parsed params
	call _RANDOM	; call internal routine
   ld a,(OP1+6)	; get the random nr stored in (OP1 + 6)
   pop de 			; get parsed params back
gen_rnd_loop:
	sub e				; a-e
	jp nc,gen_rnd_loop ; if result < 0, continue
	
	add a,e			; add max_val to result to make it positive
	ld e,a			; store it in a
	
	; this is to make this function inclusive of max_val
	ld a,r			; get mem refresh register
	and 00000010b	; mask bit 6 only (the last bit (7) is not altered by mem refresh)
	jp z,gen_rnd_finished
	
	inc e				; if the bit is 1, increase value
	
gen_rnd_finished:
	ld a,e			; store return value in a
	ret

; #######################################################################################
; sprites and other mem defines

; LUTS

bitmasks:
	.db 10000000b ;0
	.db 01000000b ;1
	.db 00100000b ;2
	.db 00010000b ;3
	.db 00001000b ;4
	.db 00000100b ;5
	.db 00000010b ;6
	.db 00000001b ;7

; assets

lvl1_map: ;3x16 bytes
	.db 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
	.db 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
	.db 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255

; this will grow upwards towards the stack
snake_head:	.dw 0

.end
