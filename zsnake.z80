.NOLIST
#define equ .equ
#define EQU .equ
#define end .end
#include "ti83asm.inc"
#include "tokens.inc"

WAITKEY .equ     4CFEh  ; Wait for a key and read
BUFCLR	.equ	 515Bh	; Clear the graph backup
BUFCOPY .equ	 5164h	; Copy the graph backup to the screen
RINDOFF .equ	 4795h	; Turn off runindicator
PRINTHL .equ	 4709h	; Print HL in dec. on the screen
OP2TOP1 .equ	 41C2h	; Move OP2 to OP1
CONVOP1 .equ	 4EFCh	; Convert fp value in OP1 to a 2 byte hex
READKEY .equ	 4A18h	; Read key and place it in OP2 as a fp value
GOHOME	.equ	 47A1h	; Go to home screen (finish gfx program)
CLRTSHD .equ	 4765h	; Clear text shadow
HOMEUP	.equ	 4775h	; Place cursor at home
STRING	.equ	 470Dh	; Print 0 terminated string to screen (hl->string)

VIDMEM	.equ	8E29h ; video mem

.LIST
.org 9327h

	; prep environment
	call    RINDOFF         ; Turn off runindicator
	call    BUFCLR          ; Clear the graphbuf
	call    BUFCOPY         ; Copy the graphbuf to the LCD
	
main_loop:
	;96x64... ie 12x64 bytes
	
	ld a,255 ; TODO: 255 is too small!!
	call gen_rnd
	ld (pos_x),a
	
	ld hl,VIDMEM
	ld c,a
	ld b,0
	add hl,bc
	ld (hl), 10101010b
	call BUFCOPY
	
	
	
	jp main_loop
	
	;ld e,a
   ;ld d,0
   ;ex de,hl ;de is now garbage
   ;call _dispHL
	ret

pos_x:	.db	0
pos_y:	.db	0
max_len:	.db	64
snake_head:	
.dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
.dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
.dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
.dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

; #######################################################################################
; gen_rnd: generate a random number from 0 up to and including max
;
; reg a = max value <256
; kills e
; returns a
; #######################################################################################
gen_rnd:
	ld e,a
	push de			; save parsed params
	call _RANDOM	; call internal routine
   ld a,(OP1+6)	; get the random nr stored in (OP1 + 6)
   pop de 			; get parsed params back
gen_rnd_loop:
	sub e				; a-e
	jp nc,gen_rnd_loop ; if result < 0, continue
	
	add a,e			; add max_val to result to make it positive
	ld e,a			; store it in a
	
	; this is to make this function inclusive of max_val
	ld a,r			; get mem refresh register
	and 00000010b	; mask bit 6 only (the last bit (7) is not altered by mem refresh)
	jp z,gen_rnd_finished
	
	inc e				; if the bit is 1, increase value
	
gen_rnd_finished:
	ld a,e			; store return value in a
	ret

mem: ;This is your label.
.db "FILLERFILLERFILLERFILLERFILLER"
.db "FILLERFILLERFILLERFILLERFILLER"
.db "FILLERFILLERFILLERFILLERFILLER"
.db "FILLERFILLERFILLERFILLERFILLER",0
.end
